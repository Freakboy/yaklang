// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.21.12
// source: exec_yak_script.proto

package ypb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	ExecYakScriptService_Exec_FullMethodName                                     = "/ypb.ExecYakScriptService/Exec"
	ExecYakScriptService_QueryExecHistory_FullMethodName                         = "/ypb.ExecYakScriptService/QueryExecHistory"
	ExecYakScriptService_RemoveExecHistory_FullMethodName                        = "/ypb.ExecYakScriptService/RemoveExecHistory"
	ExecYakScriptService_LoadNucleiTemplates_FullMethodName                      = "/ypb.ExecYakScriptService/LoadNucleiTemplates"
	ExecYakScriptService_AutoUpdateYakModule_FullMethodName                      = "/ypb.ExecYakScriptService/AutoUpdateYakModule"
	ExecYakScriptService_ExecYakScript_FullMethodName                            = "/ypb.ExecYakScriptService/ExecYakScript"
	ExecYakScriptService_ExecBatchYakScript_FullMethodName                       = "/ypb.ExecYakScriptService/ExecBatchYakScript"
	ExecYakScriptService_GetExecBatchYakScriptUnfinishedTask_FullMethodName      = "/ypb.ExecYakScriptService/GetExecBatchYakScriptUnfinishedTask"
	ExecYakScriptService_GetExecBatchYakScriptUnfinishedTaskByUid_FullMethodName = "/ypb.ExecYakScriptService/GetExecBatchYakScriptUnfinishedTaskByUid"
	ExecYakScriptService_PopExecBatchYakScriptUnfinishedTaskByUid_FullMethodName = "/ypb.ExecYakScriptService/PopExecBatchYakScriptUnfinishedTaskByUid"
	ExecYakScriptService_RecoverExecBatchYakScriptUnfinishedTask_FullMethodName  = "/ypb.ExecYakScriptService/RecoverExecBatchYakScriptUnfinishedTask"
)

// ExecYakScriptServiceClient is the client API for ExecYakScriptService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ExecYakScriptServiceClient interface {
	// Exec
	Exec(ctx context.Context, in *ExecRequest, opts ...grpc.CallOption) (ExecYakScriptService_ExecClient, error)
	QueryExecHistory(ctx context.Context, in *ExecHistoryRequest, opts ...grpc.CallOption) (*ExecHistoryRecordResponse, error)
	RemoveExecHistory(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	LoadNucleiTemplates(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	AutoUpdateYakModule(ctx context.Context, in *Empty, opts ...grpc.CallOption) (ExecYakScriptService_AutoUpdateYakModuleClient, error)
	ExecYakScript(ctx context.Context, in *ExecRequest, opts ...grpc.CallOption) (ExecYakScriptService_ExecYakScriptClient, error)
	ExecBatchYakScript(ctx context.Context, in *ExecBatchYakScriptRequest, opts ...grpc.CallOption) (ExecYakScriptService_ExecBatchYakScriptClient, error)
	GetExecBatchYakScriptUnfinishedTask(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetExecBatchYakScriptUnfinishedTaskResponse, error)
	GetExecBatchYakScriptUnfinishedTaskByUid(ctx context.Context, in *GetExecBatchYakScriptUnfinishedTaskByUidRequest, opts ...grpc.CallOption) (*ExecBatchYakScriptRequest, error)
	PopExecBatchYakScriptUnfinishedTaskByUid(ctx context.Context, in *GetExecBatchYakScriptUnfinishedTaskByUidRequest, opts ...grpc.CallOption) (*ExecBatchYakScriptRequest, error)
	RecoverExecBatchYakScriptUnfinishedTask(ctx context.Context, in *RecoverExecBatchYakScriptUnfinishedTaskRequest, opts ...grpc.CallOption) (ExecYakScriptService_RecoverExecBatchYakScriptUnfinishedTaskClient, error)
}

type execYakScriptServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewExecYakScriptServiceClient(cc grpc.ClientConnInterface) ExecYakScriptServiceClient {
	return &execYakScriptServiceClient{cc}
}

func (c *execYakScriptServiceClient) Exec(ctx context.Context, in *ExecRequest, opts ...grpc.CallOption) (ExecYakScriptService_ExecClient, error) {
	stream, err := c.cc.NewStream(ctx, &ExecYakScriptService_ServiceDesc.Streams[0], ExecYakScriptService_Exec_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &execYakScriptServiceExecClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ExecYakScriptService_ExecClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type execYakScriptServiceExecClient struct {
	grpc.ClientStream
}

func (x *execYakScriptServiceExecClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *execYakScriptServiceClient) QueryExecHistory(ctx context.Context, in *ExecHistoryRequest, opts ...grpc.CallOption) (*ExecHistoryRecordResponse, error) {
	out := new(ExecHistoryRecordResponse)
	err := c.cc.Invoke(ctx, ExecYakScriptService_QueryExecHistory_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *execYakScriptServiceClient) RemoveExecHistory(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, ExecYakScriptService_RemoveExecHistory_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *execYakScriptServiceClient) LoadNucleiTemplates(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, ExecYakScriptService_LoadNucleiTemplates_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *execYakScriptServiceClient) AutoUpdateYakModule(ctx context.Context, in *Empty, opts ...grpc.CallOption) (ExecYakScriptService_AutoUpdateYakModuleClient, error) {
	stream, err := c.cc.NewStream(ctx, &ExecYakScriptService_ServiceDesc.Streams[1], ExecYakScriptService_AutoUpdateYakModule_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &execYakScriptServiceAutoUpdateYakModuleClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ExecYakScriptService_AutoUpdateYakModuleClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type execYakScriptServiceAutoUpdateYakModuleClient struct {
	grpc.ClientStream
}

func (x *execYakScriptServiceAutoUpdateYakModuleClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *execYakScriptServiceClient) ExecYakScript(ctx context.Context, in *ExecRequest, opts ...grpc.CallOption) (ExecYakScriptService_ExecYakScriptClient, error) {
	stream, err := c.cc.NewStream(ctx, &ExecYakScriptService_ServiceDesc.Streams[2], ExecYakScriptService_ExecYakScript_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &execYakScriptServiceExecYakScriptClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ExecYakScriptService_ExecYakScriptClient interface {
	Recv() (*ExecResult, error)
	grpc.ClientStream
}

type execYakScriptServiceExecYakScriptClient struct {
	grpc.ClientStream
}

func (x *execYakScriptServiceExecYakScriptClient) Recv() (*ExecResult, error) {
	m := new(ExecResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *execYakScriptServiceClient) ExecBatchYakScript(ctx context.Context, in *ExecBatchYakScriptRequest, opts ...grpc.CallOption) (ExecYakScriptService_ExecBatchYakScriptClient, error) {
	stream, err := c.cc.NewStream(ctx, &ExecYakScriptService_ServiceDesc.Streams[3], ExecYakScriptService_ExecBatchYakScript_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &execYakScriptServiceExecBatchYakScriptClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ExecYakScriptService_ExecBatchYakScriptClient interface {
	Recv() (*ExecBatchYakScriptResult, error)
	grpc.ClientStream
}

type execYakScriptServiceExecBatchYakScriptClient struct {
	grpc.ClientStream
}

func (x *execYakScriptServiceExecBatchYakScriptClient) Recv() (*ExecBatchYakScriptResult, error) {
	m := new(ExecBatchYakScriptResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *execYakScriptServiceClient) GetExecBatchYakScriptUnfinishedTask(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetExecBatchYakScriptUnfinishedTaskResponse, error) {
	out := new(GetExecBatchYakScriptUnfinishedTaskResponse)
	err := c.cc.Invoke(ctx, ExecYakScriptService_GetExecBatchYakScriptUnfinishedTask_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *execYakScriptServiceClient) GetExecBatchYakScriptUnfinishedTaskByUid(ctx context.Context, in *GetExecBatchYakScriptUnfinishedTaskByUidRequest, opts ...grpc.CallOption) (*ExecBatchYakScriptRequest, error) {
	out := new(ExecBatchYakScriptRequest)
	err := c.cc.Invoke(ctx, ExecYakScriptService_GetExecBatchYakScriptUnfinishedTaskByUid_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *execYakScriptServiceClient) PopExecBatchYakScriptUnfinishedTaskByUid(ctx context.Context, in *GetExecBatchYakScriptUnfinishedTaskByUidRequest, opts ...grpc.CallOption) (*ExecBatchYakScriptRequest, error) {
	out := new(ExecBatchYakScriptRequest)
	err := c.cc.Invoke(ctx, ExecYakScriptService_PopExecBatchYakScriptUnfinishedTaskByUid_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *execYakScriptServiceClient) RecoverExecBatchYakScriptUnfinishedTask(ctx context.Context, in *RecoverExecBatchYakScriptUnfinishedTaskRequest, opts ...grpc.CallOption) (ExecYakScriptService_RecoverExecBatchYakScriptUnfinishedTaskClient, error) {
	stream, err := c.cc.NewStream(ctx, &ExecYakScriptService_ServiceDesc.Streams[4], ExecYakScriptService_RecoverExecBatchYakScriptUnfinishedTask_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &execYakScriptServiceRecoverExecBatchYakScriptUnfinishedTaskClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ExecYakScriptService_RecoverExecBatchYakScriptUnfinishedTaskClient interface {
	Recv() (*ExecBatchYakScriptResult, error)
	grpc.ClientStream
}

type execYakScriptServiceRecoverExecBatchYakScriptUnfinishedTaskClient struct {
	grpc.ClientStream
}

func (x *execYakScriptServiceRecoverExecBatchYakScriptUnfinishedTaskClient) Recv() (*ExecBatchYakScriptResult, error) {
	m := new(ExecBatchYakScriptResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ExecYakScriptServiceServer is the server API for ExecYakScriptService service.
// All implementations must embed UnimplementedExecYakScriptServiceServer
// for forward compatibility
type ExecYakScriptServiceServer interface {
	// Exec
	Exec(*ExecRequest, ExecYakScriptService_ExecServer) error
	QueryExecHistory(context.Context, *ExecHistoryRequest) (*ExecHistoryRecordResponse, error)
	RemoveExecHistory(context.Context, *Empty) (*Empty, error)
	LoadNucleiTemplates(context.Context, *Empty) (*Empty, error)
	AutoUpdateYakModule(*Empty, ExecYakScriptService_AutoUpdateYakModuleServer) error
	ExecYakScript(*ExecRequest, ExecYakScriptService_ExecYakScriptServer) error
	ExecBatchYakScript(*ExecBatchYakScriptRequest, ExecYakScriptService_ExecBatchYakScriptServer) error
	GetExecBatchYakScriptUnfinishedTask(context.Context, *Empty) (*GetExecBatchYakScriptUnfinishedTaskResponse, error)
	GetExecBatchYakScriptUnfinishedTaskByUid(context.Context, *GetExecBatchYakScriptUnfinishedTaskByUidRequest) (*ExecBatchYakScriptRequest, error)
	PopExecBatchYakScriptUnfinishedTaskByUid(context.Context, *GetExecBatchYakScriptUnfinishedTaskByUidRequest) (*ExecBatchYakScriptRequest, error)
	RecoverExecBatchYakScriptUnfinishedTask(*RecoverExecBatchYakScriptUnfinishedTaskRequest, ExecYakScriptService_RecoverExecBatchYakScriptUnfinishedTaskServer) error
	mustEmbedUnimplementedExecYakScriptServiceServer()
}

// UnimplementedExecYakScriptServiceServer must be embedded to have forward compatible implementations.
type UnimplementedExecYakScriptServiceServer struct {
}

func (UnimplementedExecYakScriptServiceServer) Exec(*ExecRequest, ExecYakScriptService_ExecServer) error {
	return status.Errorf(codes.Unimplemented, "method Exec not implemented")
}
func (UnimplementedExecYakScriptServiceServer) QueryExecHistory(context.Context, *ExecHistoryRequest) (*ExecHistoryRecordResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryExecHistory not implemented")
}
func (UnimplementedExecYakScriptServiceServer) RemoveExecHistory(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveExecHistory not implemented")
}
func (UnimplementedExecYakScriptServiceServer) LoadNucleiTemplates(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadNucleiTemplates not implemented")
}
func (UnimplementedExecYakScriptServiceServer) AutoUpdateYakModule(*Empty, ExecYakScriptService_AutoUpdateYakModuleServer) error {
	return status.Errorf(codes.Unimplemented, "method AutoUpdateYakModule not implemented")
}
func (UnimplementedExecYakScriptServiceServer) ExecYakScript(*ExecRequest, ExecYakScriptService_ExecYakScriptServer) error {
	return status.Errorf(codes.Unimplemented, "method ExecYakScript not implemented")
}
func (UnimplementedExecYakScriptServiceServer) ExecBatchYakScript(*ExecBatchYakScriptRequest, ExecYakScriptService_ExecBatchYakScriptServer) error {
	return status.Errorf(codes.Unimplemented, "method ExecBatchYakScript not implemented")
}
func (UnimplementedExecYakScriptServiceServer) GetExecBatchYakScriptUnfinishedTask(context.Context, *Empty) (*GetExecBatchYakScriptUnfinishedTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExecBatchYakScriptUnfinishedTask not implemented")
}
func (UnimplementedExecYakScriptServiceServer) GetExecBatchYakScriptUnfinishedTaskByUid(context.Context, *GetExecBatchYakScriptUnfinishedTaskByUidRequest) (*ExecBatchYakScriptRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExecBatchYakScriptUnfinishedTaskByUid not implemented")
}
func (UnimplementedExecYakScriptServiceServer) PopExecBatchYakScriptUnfinishedTaskByUid(context.Context, *GetExecBatchYakScriptUnfinishedTaskByUidRequest) (*ExecBatchYakScriptRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PopExecBatchYakScriptUnfinishedTaskByUid not implemented")
}
func (UnimplementedExecYakScriptServiceServer) RecoverExecBatchYakScriptUnfinishedTask(*RecoverExecBatchYakScriptUnfinishedTaskRequest, ExecYakScriptService_RecoverExecBatchYakScriptUnfinishedTaskServer) error {
	return status.Errorf(codes.Unimplemented, "method RecoverExecBatchYakScriptUnfinishedTask not implemented")
}
func (UnimplementedExecYakScriptServiceServer) mustEmbedUnimplementedExecYakScriptServiceServer() {}

// UnsafeExecYakScriptServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ExecYakScriptServiceServer will
// result in compilation errors.
type UnsafeExecYakScriptServiceServer interface {
	mustEmbedUnimplementedExecYakScriptServiceServer()
}

func RegisterExecYakScriptServiceServer(s grpc.ServiceRegistrar, srv ExecYakScriptServiceServer) {
	s.RegisterService(&ExecYakScriptService_ServiceDesc, srv)
}

func _ExecYakScriptService_Exec_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExecYakScriptServiceServer).Exec(m, &execYakScriptServiceExecServer{stream})
}

type ExecYakScriptService_ExecServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type execYakScriptServiceExecServer struct {
	grpc.ServerStream
}

func (x *execYakScriptServiceExecServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _ExecYakScriptService_QueryExecHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecYakScriptServiceServer).QueryExecHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExecYakScriptService_QueryExecHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecYakScriptServiceServer).QueryExecHistory(ctx, req.(*ExecHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExecYakScriptService_RemoveExecHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecYakScriptServiceServer).RemoveExecHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExecYakScriptService_RemoveExecHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecYakScriptServiceServer).RemoveExecHistory(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExecYakScriptService_LoadNucleiTemplates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecYakScriptServiceServer).LoadNucleiTemplates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExecYakScriptService_LoadNucleiTemplates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecYakScriptServiceServer).LoadNucleiTemplates(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExecYakScriptService_AutoUpdateYakModule_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExecYakScriptServiceServer).AutoUpdateYakModule(m, &execYakScriptServiceAutoUpdateYakModuleServer{stream})
}

type ExecYakScriptService_AutoUpdateYakModuleServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type execYakScriptServiceAutoUpdateYakModuleServer struct {
	grpc.ServerStream
}

func (x *execYakScriptServiceAutoUpdateYakModuleServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _ExecYakScriptService_ExecYakScript_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExecYakScriptServiceServer).ExecYakScript(m, &execYakScriptServiceExecYakScriptServer{stream})
}

type ExecYakScriptService_ExecYakScriptServer interface {
	Send(*ExecResult) error
	grpc.ServerStream
}

type execYakScriptServiceExecYakScriptServer struct {
	grpc.ServerStream
}

func (x *execYakScriptServiceExecYakScriptServer) Send(m *ExecResult) error {
	return x.ServerStream.SendMsg(m)
}

func _ExecYakScriptService_ExecBatchYakScript_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecBatchYakScriptRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExecYakScriptServiceServer).ExecBatchYakScript(m, &execYakScriptServiceExecBatchYakScriptServer{stream})
}

type ExecYakScriptService_ExecBatchYakScriptServer interface {
	Send(*ExecBatchYakScriptResult) error
	grpc.ServerStream
}

type execYakScriptServiceExecBatchYakScriptServer struct {
	grpc.ServerStream
}

func (x *execYakScriptServiceExecBatchYakScriptServer) Send(m *ExecBatchYakScriptResult) error {
	return x.ServerStream.SendMsg(m)
}

func _ExecYakScriptService_GetExecBatchYakScriptUnfinishedTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecYakScriptServiceServer).GetExecBatchYakScriptUnfinishedTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExecYakScriptService_GetExecBatchYakScriptUnfinishedTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecYakScriptServiceServer).GetExecBatchYakScriptUnfinishedTask(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExecYakScriptService_GetExecBatchYakScriptUnfinishedTaskByUid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExecBatchYakScriptUnfinishedTaskByUidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecYakScriptServiceServer).GetExecBatchYakScriptUnfinishedTaskByUid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExecYakScriptService_GetExecBatchYakScriptUnfinishedTaskByUid_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecYakScriptServiceServer).GetExecBatchYakScriptUnfinishedTaskByUid(ctx, req.(*GetExecBatchYakScriptUnfinishedTaskByUidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExecYakScriptService_PopExecBatchYakScriptUnfinishedTaskByUid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExecBatchYakScriptUnfinishedTaskByUidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecYakScriptServiceServer).PopExecBatchYakScriptUnfinishedTaskByUid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExecYakScriptService_PopExecBatchYakScriptUnfinishedTaskByUid_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecYakScriptServiceServer).PopExecBatchYakScriptUnfinishedTaskByUid(ctx, req.(*GetExecBatchYakScriptUnfinishedTaskByUidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExecYakScriptService_RecoverExecBatchYakScriptUnfinishedTask_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RecoverExecBatchYakScriptUnfinishedTaskRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExecYakScriptServiceServer).RecoverExecBatchYakScriptUnfinishedTask(m, &execYakScriptServiceRecoverExecBatchYakScriptUnfinishedTaskServer{stream})
}

type ExecYakScriptService_RecoverExecBatchYakScriptUnfinishedTaskServer interface {
	Send(*ExecBatchYakScriptResult) error
	grpc.ServerStream
}

type execYakScriptServiceRecoverExecBatchYakScriptUnfinishedTaskServer struct {
	grpc.ServerStream
}

func (x *execYakScriptServiceRecoverExecBatchYakScriptUnfinishedTaskServer) Send(m *ExecBatchYakScriptResult) error {
	return x.ServerStream.SendMsg(m)
}

// ExecYakScriptService_ServiceDesc is the grpc.ServiceDesc for ExecYakScriptService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ExecYakScriptService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ypb.ExecYakScriptService",
	HandlerType: (*ExecYakScriptServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QueryExecHistory",
			Handler:    _ExecYakScriptService_QueryExecHistory_Handler,
		},
		{
			MethodName: "RemoveExecHistory",
			Handler:    _ExecYakScriptService_RemoveExecHistory_Handler,
		},
		{
			MethodName: "LoadNucleiTemplates",
			Handler:    _ExecYakScriptService_LoadNucleiTemplates_Handler,
		},
		{
			MethodName: "GetExecBatchYakScriptUnfinishedTask",
			Handler:    _ExecYakScriptService_GetExecBatchYakScriptUnfinishedTask_Handler,
		},
		{
			MethodName: "GetExecBatchYakScriptUnfinishedTaskByUid",
			Handler:    _ExecYakScriptService_GetExecBatchYakScriptUnfinishedTaskByUid_Handler,
		},
		{
			MethodName: "PopExecBatchYakScriptUnfinishedTaskByUid",
			Handler:    _ExecYakScriptService_PopExecBatchYakScriptUnfinishedTaskByUid_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Exec",
			Handler:       _ExecYakScriptService_Exec_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AutoUpdateYakModule",
			Handler:       _ExecYakScriptService_AutoUpdateYakModule_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExecYakScript",
			Handler:       _ExecYakScriptService_ExecYakScript_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExecBatchYakScript",
			Handler:       _ExecYakScriptService_ExecBatchYakScript_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RecoverExecBatchYakScriptUnfinishedTask",
			Handler:       _ExecYakScriptService_RecoverExecBatchYakScriptUnfinishedTask_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "exec_yak_script.proto",
}
